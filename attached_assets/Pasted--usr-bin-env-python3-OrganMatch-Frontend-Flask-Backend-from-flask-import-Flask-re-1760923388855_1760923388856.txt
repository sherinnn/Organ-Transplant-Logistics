#!/usr/bin/env python3
"""
OrganMatch Frontend - Flask Backend
"""

from flask import Flask, render_template, request, jsonify, session
from flask_cors import CORS
import boto3
import json
import uuid
import random
from datetime import datetime, timedelta
import os
from dotenv import load_dotenv

load_dotenv()

app = Flask(__name__)
app.secret_key = os.urandom(24)
CORS(app)

# AWS Configuration
REGION = "us-east-1"
GATEWAY_ID = "xxx"
MODEL_ID = "xxx"
AGENT_ID = "xxx"
AGENT_ALIAS_ID = "xxx"

# Initialize AWS clients
bedrock_runtime = boto3.client("bedrock-runtime", region_name=REGION)
bedrock_agent_runtime = boto3.client("bedrock-agent-runtime", region_name=REGION)

# Try to initialize AgentCore client (may not be available in all SDK versions)
try:
    agentcore_client = boto3.client("bedrock-agentcore-control", region_name=REGION)
    AGENTCORE_AVAILABLE = True
except Exception:
    agentcore_client = None
    AGENTCORE_AVAILABLE = False

class OrganMatchBackend:
    """Backend logic for OrganMatch operations"""
    
    def __init__(self):
        self.bedrock_runtime = bedrock_runtime
        self.bedrock_agent_runtime = bedrock_agent_runtime
        self.agentcore_client = agentcore_client
        self.session_id = str(uuid.uuid4())
        
        # Load gateway target mappings
        self.gateway_targets = self._load_gateway_targets() if AGENTCORE_AVAILABLE else {}
    
    def _load_gateway_targets(self):
        """Load gateway target mappings for tool invocation"""
        
        if not self.agentcore_client:
            return {}
        
        try:
            targets = self.agentcore_client.list_gateway_targets(gatewayIdentifier=GATEWAY_ID)
            target_map = {}
            
            for target in targets.get("items", []):
                target_map[target["name"]] = target["targetId"]
            
            print(f"‚úÖ Loaded {len(target_map)} gateway targets")
            return target_map
            
        except Exception as e:
            print(f"‚ö†Ô∏è Could not load gateway targets: {e}")
            return {}
    
    def invoke_agent(self, prompt, context=None):
        """Invoke the OrganMatch agent with context - tries AgentCore first, falls back to direct model"""
        
        # Try AgentCore agent first
        agent_result = self._try_agentcore_invoke(prompt, context)
        if agent_result["success"]:
            return agent_result
        
        # Fallback to direct model invocation
        return self._invoke_direct_model(prompt, context)
    
    def _try_agentcore_invoke(self, prompt, context=None):
        """Try to invoke the actual Bedrock agent"""
        
        try:
            # Prepare the input text
            if context:
                context_str = f"Context: {json.dumps(context, indent=2)}\n\n"
                input_text = f"{context_str}{prompt}"
            else:
                input_text = prompt
            
            # Invoke the agent
            response = self.bedrock_agent_runtime.invoke_agent(
                agentId=AGENT_ID,
                agentAliasId=AGENT_ALIAS_ID,
                sessionId=self.session_id,
                inputText=input_text,
                enableTrace=True
            )
            
            # Process the streaming response
            full_response = ""
            traces = []
            
            for event in response['completion']:
                if 'chunk' in event:
                    chunk = event['chunk']
                    if 'bytes' in chunk:
                        text = chunk['bytes'].decode('utf-8')
                        full_response += text
                
                elif 'trace' in event:
                    traces.append(event['trace'])
            
            return {
                "success": True,
                "response": full_response,
                "method": "agentcore",
                "traces": len(traces)
            }
            
        except Exception as e:
            return {
                "success": False,
                "error": str(e),
                "method": "agentcore"
            }
    
    def _invoke_direct_model(self, prompt, context=None):
        """Fallback to direct model invocation"""
        
        system_prompt = """You are OrganMatch Agent, an AI assistant that helps hospitals and transplant coordinators manage organ logistics. 

You have access to these tools:
1. viability-tool: Check organ viability based on time, temperature, and condition
2. weather-tool: Get weather data for transport planning
3. flight-tool: Find flights between cities for organ transport
4. matcher-tool: Match donors and recipients for compatibility

Provide helpful, professional responses for organ logistics scenarios."""
        
        if context:
            context_str = f"\nContext: {json.dumps(context, indent=2)}"
            full_prompt = f"{system_prompt}{context_str}\n\nUser: {prompt}\n\nOrganMatch Agent:"
        else:
            full_prompt = f"{system_prompt}\n\nUser: {prompt}\n\nOrganMatch Agent:"
        
        body = json.dumps({
            "anthropic_version": "bedrock-2023-05-31",
            "max_tokens": 800,
            "messages": [
                {
                    "role": "user",
                    "content": full_prompt
                }
            ]
        })
        
        try:
            response = self.bedrock_runtime.invoke_model(
                modelId=MODEL_ID,
                body=body
            )
            
            response_body = json.loads(response['body'].read())
            return {
                "success": True,
                "response": response_body['content'][0]['text'],
                "method": "direct_model"
            }
            
        except Exception as e:
            return {
                "success": False,
                "error": str(e),
                "method": "direct_model"
            }
    
    def invoke_gateway_tool(self, tool_name, parameters):
        """Invoke a specific gateway tool via AgentCore"""
        
        if not self.agentcore_client or tool_name not in self.gateway_targets:
            return {"success": False, "error": f"Tool {tool_name} not available via gateway"}
        
        target_id = self.gateway_targets[tool_name]
        
        try:
            # Try different invoke methods based on SDK version
            invoke_methods = ["invoke_gateway_target", "invoke_target"]
            
            for method_name in invoke_methods:
                if hasattr(self.agentcore_client, method_name):
                    try:
                        method = getattr(self.agentcore_client, method_name)
                        response = method(
                            gatewayIdentifier=GATEWAY_ID,
                            targetId=target_id,
                            input=json.dumps(parameters)
                        )
                        
                        # Parse response
                        output = response.get('output', {})
                        if isinstance(output, str):
                            try:
                                output = json.loads(output)
                            except:
                                pass
                        
                        return {
                            "success": True,
                            "result": output,
                            "method": method_name
                        }
                        
                    except Exception as e:
                        continue
            
            return {"success": False, "error": "No compatible invoke method found"}
            
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    def check_viability(self, organ_data):
        """Check organ viability - tries gateway first, falls back to simulation"""
        
        # Try gateway tool first
        if AGENTCORE_AVAILABLE and "viability-tool" in self.gateway_targets:
            gateway_params = {
                "organ_type": organ_data.get("type", "heart"),
                "time_of_death": organ_data.get("donation_time", datetime.now().isoformat()),
                "current_time": datetime.now().isoformat(),
                "temperature_c": organ_data.get("temperature", 4),
                "organ_condition_score": organ_data.get("condition_score", 85)
            }
            
            gateway_result = self.invoke_gateway_tool("viability-tool", gateway_params)
            if gateway_result["success"]:
                result = gateway_result["result"]
                result["method"] = "gateway"
                return result
        
        # Fallback to simulation
        return self._simulate_viability_check(organ_data)
    
    def _simulate_viability_check(self, organ_data):
        """Simulate organ viability checking"""
        
        organ_type = organ_data.get("type", "heart").lower()
        donation_time = organ_data.get("donation_time")
        temperature = organ_data.get("temperature", 4)
        condition_score = organ_data.get("condition_score", 85)
        
        # Calculate hours elapsed
        if donation_time:
            try:
                donation_dt = datetime.fromisoformat(donation_time.replace('Z', '+00:00'))
                current_dt = datetime.now()
                hours_elapsed = (current_dt - donation_dt).total_seconds() / 3600
            except:
                hours_elapsed = 0
        else:
            hours_elapsed = 0
        
        # Viability logic
        max_hours = {"heart": 6, "liver": 12, "kidney": 24, "lung": 8}.get(organ_type, 6)
        temp_factor = 1.0 if temperature <= 4 else 0.7
        condition_factor = condition_score / 100
        
        hours_left = max(0, (max_hours - hours_elapsed) * temp_factor * condition_factor)
        is_viable = hours_left > 0.5
        
        return {
            "is_viable": is_viable,
            "hours_left": round(hours_left, 1),
            "hours_elapsed": round(hours_elapsed, 1),
            "max_hours": max_hours,
            "recommendation": "Proceed with transport" if is_viable else "Consider alternative options",
            "urgency": "High" if hours_left < 2 else "Medium" if hours_left < 4 else "Low",
            "method": "simulation"
        }
    
    def get_weather(self, location, latitude=None, longitude=None):
        """Get weather data - tries gateway first, falls back to simulation"""
        
        # Try gateway tool first
        if AGENTCORE_AVAILABLE and "weather-tool" in self.gateway_targets:
            # Use provided coordinates or default ones for common cities
            coords = self._get_coordinates(location, latitude, longitude)
            
            gateway_params = {
                "latitude": coords["lat"],
                "longitude": coords["lon"]
            }
            
            gateway_result = self.invoke_gateway_tool("weather-tool", gateway_params)
            if gateway_result["success"]:
                result = gateway_result["result"]
                result["method"] = "gateway"
                result["location"] = location
                return result
        
        # Fallback to simulation
        return self._simulate_weather_data(location)
    
    def _get_coordinates(self, location, latitude=None, longitude=None):
        """Get coordinates for a location"""
        
        if latitude is not None and longitude is not None:
            return {"lat": latitude, "lon": longitude}
        
        # Common city coordinates
        city_coords = {
            "boston": {"lat": 42.3601, "lon": -71.0589},
            "new york": {"lat": 40.7128, "lon": -74.0060},
            "los angeles": {"lat": 34.0522, "lon": -118.2437},
            "chicago": {"lat": 41.8781, "lon": -87.6298},
            "miami": {"lat": 25.7617, "lon": -80.1918},
            "seattle": {"lat": 47.6062, "lon": -122.3321}
        }
        
        location_lower = location.lower()
        return city_coords.get(location_lower, {"lat": 42.3601, "lon": -71.0589})
    
    def _simulate_weather_data(self, location):
        """Simulate weather data"""
        
        weather_data = {
            "temperature_c": 15,
            "condition": "Clear",
            "wind_kph": 12,
            "visibility_km": 10,
            "humidity": 65,
            "transport_suitability": "Excellent",
            "location": location,
            "method": "simulation"
        }
        
        return weather_data
    
    def search_flights(self, origin, destination, date=None):
        """Search flights - tries gateway first, falls back to simulation"""
        
        # Try gateway tool first
        if AGENTCORE_AVAILABLE and "flight-tool" in self.gateway_targets:
            gateway_params = {
                "origin": origin,
                "destination": destination,
                "departure_date": date or datetime.now().strftime("%Y-%m-%d")
            }
            
            gateway_result = self.invoke_gateway_tool("flight-tool", gateway_params)
            if gateway_result["success"]:
                result = gateway_result["result"]
                result["method"] = "gateway"
                return result
        
        # Fallback to simulation
        return self._simulate_flight_search(origin, destination, date)
    
    def _simulate_flight_search(self, origin, destination, date=None):
        """Simulate flight search"""
        
        # Simulate flight data
        flights = [
            {
                "flight": f"AA{123 + hash(origin) % 900}",
                "departure": "14:30",
                "arrival": "18:45", 
                "duration": "6h 15m",
                "aircraft": "Boeing 737",
                "price": "$450"
            },
            {
                "flight": f"DL{456 + hash(destination) % 900}",
                "departure": "16:00",
                "arrival": "20:30",
                "duration": "6h 30m", 
                "aircraft": "Airbus A320",
                "price": "$380"
            },
            {
                "flight": f"UA{789 + hash(origin + destination) % 900}",
                "departure": "18:15",
                "arrival": "22:45",
                "duration": "6h 30m",
                "aircraft": "Boeing 757",
                "price": "$420"
            }
        ]
        
        return {
            "flights": flights,
            "fastest_flight": flights[0]["flight"],
            "cheapest_flight": flights[1]["flight"],
            "recommendation": f"Book {flights[0]['flight']} for fastest transport",
            "method": "simulation"
        }
    
    def match_donor_recipient(self, donor_data, recipient_data):
        """Match donor-recipient - tries gateway first, falls back to simulation"""
        
        # Try gateway tool first
        if AGENTCORE_AVAILABLE and "matcher-tool" in self.gateway_targets:
            gateway_params = {
                "donor_id": donor_data.get("id", "D123"),
                "recipient_id": recipient_data.get("id", "R456")
            }
            
            gateway_result = self.invoke_gateway_tool("matcher-tool", gateway_params)
            if gateway_result["success"]:
                result = gateway_result["result"]
                result["method"] = "gateway"
                return result
        
        # Fallback to simulation
        return self._simulate_donor_matching(donor_data, recipient_data)
    
    def _simulate_donor_matching(self, donor_data, recipient_data):
        """Simulate donor-recipient matching"""
        
        # Simple matching logic
        blood_match = donor_data.get("blood_type") == recipient_data.get("blood_type")
        
        # Simulate compatibility score
        base_score = 85 if blood_match else 20
        age_factor = max(0, 100 - abs(donor_data.get("age", 30) - recipient_data.get("age", 40)))
        
        match_score = min(100, (base_score + age_factor) / 2)
        is_compatible = match_score > 70
        
        return {
            "is_compatible": is_compatible,
            "match_score": round(match_score, 1),
            "blood_type_match": blood_match,
            "tissue_compatibility": "Excellent" if match_score > 85 else "Good" if match_score > 70 else "Poor",
            "recommendation": "Proceed with transplant" if is_compatible else "Consider alternative recipients",
            "method": "simulation"
        }

# Initialize backend
backend = OrganMatchBackend()

@app.route('/')
def index():
    """Landing page matching the design"""
    return render_template('landing_page.html')

@app.route('/agentcore')
def agentcore_dashboard():
    """AgentCore integration dashboard"""
    return render_template('agentcore_dashboard.html')

@app.route('/dashboard')
def main_dashboard():
    """Main OrganMatch AI dashboard"""
    section = request.args.get('section', 'overview')
    return render_template('organmatch_dashboard.html', active_section=section)

@app.route('/api/check-viability', methods=['POST'])
def check_viability():
    """API endpoint for viability checking"""
    
    data = request.get_json()
    organ_data = data.get('organ', {})
    
    result = backend.check_viability(organ_data)
    return jsonify(result)

@app.route('/api/get-weather', methods=['POST'])
def get_weather():
    """API endpoint for weather data"""
    
    data = request.get_json()
    location = data.get('location', 'Boston')
    
    result = backend.get_weather(location)
    return jsonify(result)

@app.route('/api/search-flights', methods=['POST'])
def search_flights():
    """API endpoint for flight search"""
    
    data = request.get_json()
    origin = data.get('origin', 'BOS')
    destination = data.get('destination', 'LAX')
    date = data.get('date')
    
    result = backend.search_flights(origin, destination, date)
    return jsonify(result)

@app.route('/api/match-compatibility', methods=['POST'])
def match_compatibility():
    """API endpoint for donor-recipient matching"""
    
    data = request.get_json()
    donor_data = data.get('donor', {})
    recipient_data = data.get('recipient', {})
    
    result = backend.match_donor_recipient(donor_data, recipient_data)
    return jsonify(result)

@app.route('/api/agent-chat', methods=['POST'])
def agent_chat():
    """API endpoint for agent conversation"""
    
    data = request.get_json()
    message = data.get('message', '')
    context = data.get('context', {})
    
    result = backend.invoke_agent(message, context)
    return jsonify(result)

@app.route('/api/agentcore-status', methods=['GET'])
def agentcore_status():
    """API endpoint to check AgentCore integration status"""
    
    status = {
        "agentcore_available": AGENTCORE_AVAILABLE,
        "gateway_id": GATEWAY_ID,
        "agent_id": AGENT_ID,
        "agent_alias_id": AGENT_ALIAS_ID,
        "gateway_targets": list(backend.gateway_targets.keys()) if backend.gateway_targets else [],
        "target_count": len(backend.gateway_targets)
    }
    
    return jsonify(status)

@app.route('/api/invoke-tool', methods=['POST'])
def invoke_tool():
    """API endpoint to directly invoke a gateway tool"""
    
    data = request.get_json()
    tool_name = data.get('tool_name')
    parameters = data.get('parameters', {})
    
    if not tool_name:
        return jsonify({"success": False, "error": "tool_name is required"})
    
    result = backend.invoke_gateway_tool(tool_name, parameters)
    return jsonify(result)

@app.route('/api/full-analysis', methods=['POST'])
def full_analysis():
    """API endpoint for complete organ logistics analysis"""
    
    data = request.get_json()
    
    # Extract data
    organ_data = data.get('organ', {})
    donor_data = data.get('donor', {})
    recipient_data = data.get('recipient', {})
    transport_data = data.get('transport', {})
    
    # Run all analyses
    viability = backend.check_viability(organ_data)
    weather = backend.get_weather(transport_data.get('origin_city', 'Boston'))
    flights = backend.search_flights(
        transport_data.get('origin', 'BOS'),
        transport_data.get('destination', 'LAX')
    )
    matching = backend.match_donor_recipient(donor_data, recipient_data)
    
    # Create comprehensive context for agent
    context = {
        "organ": organ_data,
        "donor": donor_data,
        "recipient": recipient_data,
        "transport": transport_data,
        "viability": viability,
        "weather": weather,
        "flights": flights,
        "matching": matching
    }
    
    # Get agent recommendation
    agent_prompt = f"Analyze this complete organ logistics scenario and provide recommendations for transporting a {organ_data.get('type', 'organ')} from {transport_data.get('origin_city', 'the donor location')} to {transport_data.get('destination_city', 'the recipient location')}."
    
    agent_response = backend.invoke_agent(agent_prompt, context)
    
    return jsonify({
        "viability": viability,
        "weather": weather,
        "flights": flights,
        "matching": matching,
        "agent_recommendation": agent_response,
        "overall_status": "Go" if viability["is_viable"] and matching["is_compatible"] else "Review Required"
    })

@app.route('/api/organs', methods=['GET'])
def get_organs():
    """API endpoint to get current organ data"""
    
    # Simulate organ data with real-time updates
    organs = [
        {
            "id": "H001",
            "type": "Heart",
            "icon": "ü´Ä",
            "status": "safe",
            "timeRemaining": "4.2h",
            "donorId": "D123",
            "conditionScore": 92,
            "location": "Boston Medical",
            "bloodType": "O+",
            "age": 34,
            "hlaType": "A2, B44, DR7"
        },
        {
            "id": "L002", 
            "type": "Liver",
            "icon": "ü´Å",
            "status": "warning",
            "timeRemaining": "8.7h",
            "donorId": "D124",
            "conditionScore": 78,
            "location": "Mayo Clinic",
            "bloodType": "A+",
            "age": 28,
            "hlaType": "A1, B8, DR3"
        },
        {
            "id": "K003",
            "type": "Kidney", 
            "icon": "ü´ò",
            "status": "critical",
            "timeRemaining": "1.3h",
            "donorId": "D125",
            "conditionScore": 65,
            "location": "Johns Hopkins",
            "bloodType": "B+",
            "age": 45,
            "hlaType": "A3, B7, DR2"
        }
    ]
    
    return jsonify(organs)

@app.route('/api/recipients', methods=['GET'])
def get_recipients():
    """API endpoint to get recipient matching data"""
    
    recipients = [
        {
            "id": "R456",
            "name": "Patient Alpha",
            "bloodType": "O+",
            "matchScore": 94,
            "urgency": "High",
            "hospital": "UCLA Medical",
            "waitTime": "127 days",
            "age": 42,
            "condition": "Cardiomyopathy"
        },
        {
            "id": "R457",
            "name": "Patient Beta", 
            "bloodType": "A+",
            "matchScore": 87,
            "urgency": "Medium",
            "hospital": "Mayo Clinic",
            "waitTime": "89 days",
            "age": 35,
            "condition": "Liver Cirrhosis"
        },
        {
            "id": "R458",
            "name": "Patient Gamma",
            "bloodType": "B+", 
            "matchScore": 82,
            "urgency": "Medium",
            "hospital": "Johns Hopkins",
            "waitTime": "156 days",
            "age": 51,
            "condition": "Kidney Failure"
        }
    ]
    
    return jsonify(recipients)

@app.route('/api/metrics', methods=['GET'])
def get_metrics():
    """API endpoint to get real-time metrics"""
    
    import random
    
    metrics = {
        "successfulMatches": random.randint(10, 15),
        "avgTransportTime": f"{random.uniform(3.0, 6.0):.1f}h",
        "expiryAvoidance": f"{random.randint(88, 98)}%",
        "activeTransports": random.randint(3, 8),
        "totalOrgans": random.randint(15, 25),
        "criticalOrgans": random.randint(1, 4)
    }
    
    return jsonify(metrics)

@app.route('/api/hospitals', methods=['GET'])
def get_hospitals():
    """API endpoint to get hospital data for map"""
    
    hospitals = [
        {
            "name": "Boston Medical Center",
            "lat": 42.3601,
            "lng": -71.0589,
            "beds": 15,
            "readiness": 95,
            "specialties": ["Heart", "Liver", "Kidney"],
            "contact": "+1-617-555-0123"
        },
        {
            "name": "UCLA Medical Center", 
            "lat": 34.0522,
            "lng": -118.2437,
            "beds": 8,
            "readiness": 87,
            "specialties": ["Heart", "Lung"],
            "contact": "+1-310-555-0456"
        },
        {
            "name": "Mayo Clinic",
            "lat": 44.0225,
            "lng": -92.4699, 
            "beds": 12,
            "readiness": 98,
            "specialties": ["Liver", "Kidney", "Pancreas"],
            "contact": "+1-507-555-0789"
        },
        {
            "name": "Johns Hopkins",
            "lat": 39.2904,
            "lng": -76.6122,
            "beds": 20, 
            "readiness": 92,
            "specialties": ["Heart", "Liver", "Kidney", "Lung"],
            "contact": "+1-410-555-0012"
        }
    ]
    
    return jsonify(hospitals)

@app.route('/api/notify-hospital', methods=['POST'])
def notify_hospital():
    """API endpoint to notify hospital about organ match"""
    
    data = request.get_json()
    recipient_id = data.get('recipient_id')
    
    # Simulate notification
    return jsonify({
        "success": True,
        "message": f"Hospital notified for recipient {recipient_id}",
        "timestamp": datetime.now().isoformat()
    })

@app.route('/api/reserve-organ', methods=['POST'])
def reserve_organ():
    """API endpoint to reserve organ for recipient"""
    
    data = request.get_json()
    recipient_id = data.get('recipient_id')
    organ_id = data.get('organ_id')
    
    # Simulate reservation
    return jsonify({
        "success": True,
        "message": f"Organ {organ_id} reserved for recipient {recipient_id}",
        "reservationId": f"RES{random.randint(1000, 9999)}",
        "timestamp": datetime.now().isoformat()
    })

if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0', port=5000)